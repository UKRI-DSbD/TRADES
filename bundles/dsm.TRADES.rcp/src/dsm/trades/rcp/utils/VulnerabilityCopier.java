/**
 * Copyright Israel Aerospace Industries, Eclipse contributors and others 2021. All rights reserved.
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 * 
 * SPDX-License-Identifier: EPL-2.0
 * 
 * Contributors:
 *     ELTA Ltd - initial API and implementation
 * 
 */

package dsm.trades.rcp.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import dsm.TRADES.Vulnerability;
import dsm.TRADES.ComponentType;
import dsm.TRADES.TRADESFactory;

public class VulnerabilityCopier {

	Map<Vulnerability, Vulnerability> oldToNewVulnerabilities = new HashMap<>();
	private Hashtable<String, List<String>> manifests = new Hashtable<String, List<String>>();
	private Hashtable<String, List<String>> affects = new Hashtable<String, List<String>>();

	public Vulnerability update(Vulnerability toImport, Vulnerability existingVulnerability) {
		oldToNewVulnerabilities.put(toImport, existingVulnerability);
		existingVulnerability.setId(toImport.getId());
		existingVulnerability.setName(toImport.getName());
		existingVulnerability.setVulnerabilityType(toImport.getVulnerabilityType());
		//EList<Vulnerability> getManifests();
		manifests.put(toImport.getId(), new ArrayList<String>());
		for (Vulnerability manifested : toImport.getManifests()) {
			manifests.get(toImport.getId()).add(manifested.getId());
		}
		//EList<ComponentType> getAffects();
		affects.put(toImport.getId(), new ArrayList<String>());
		for (ComponentType affected : toImport.getAffects()) {
			affects.get(toImport.getId()).add(affected.getId());
		}
		
		return existingVulnerability;
	}

	public Vulnerability copy(Vulnerability vulnerability) {
		Vulnerability result = TRADESFactory.eINSTANCE.createVulnerability();
		update(vulnerability, result);

		return result;
	}

	public Map<Vulnerability, Vulnerability> getOldToNewVulnerabilities() {
		return oldToNewVulnerabilities;
	}

	public void updateManifests(List<Vulnerability> vulnerabilities) {
		for (Vulnerability hub : vulnerabilities) {
			for (String id : manifests.get(hub.getId())) {
				List<Vulnerability> filtered = oldToNewVulnerabilities.values().stream().filter(t -> t.getId() == id).collect(Collectors.toList());
				hub.getManifests().add(filtered.get(0));
			}
		}
	}

	public void updateAffects(List<Vulnerability> vulnerabilities, List<ComponentType> componentTypes) {
		for (Vulnerability hub : vulnerabilities) {
			for (String id : manifests.get(hub.getId())) {
				List<ComponentType> filtered = componentTypes.stream().filter(t -> t.getId() == id).collect(Collectors.toList());
				hub.getAffects().add(filtered.get(0));
			}
		}
	}
}
